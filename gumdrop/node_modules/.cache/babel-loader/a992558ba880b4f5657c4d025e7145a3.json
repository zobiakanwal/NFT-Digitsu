{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"C:\\\\Users\\\\AHSAN PC\\\\Desktop\\\\digitsu\\\\gamp\\\\js\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\createForOfIteratorHelper.js\").default;\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\AHSAN PC\\\\Desktop\\\\digitsu\\\\gamp\\\\js\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\AHSAN PC\\\\Desktop\\\\digitsu\\\\gamp\\\\js\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCachedAccount = exports.cache = exports.genericCache = void 0;\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar eventEmitter_1 = require(\"../../utils/eventEmitter\");\n\nvar deserialize_1 = require(\"./deserialize\");\n\nexports.genericCache = new Map();\nvar mintCache = new Map();\nvar pendingCalls = new Map();\nvar pendingMintCalls = new Map();\nvar keyToAccountParser = new Map();\n\nvar getMintInfo = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection, pubKey) {\n    var info, data;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return connection.getAccountInfo(pubKey);\n\n          case 2:\n            info = _context.sent;\n\n            if (!(info === null)) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new Error('Failed to find mint account');\n\n          case 5:\n            data = Buffer.from(info.data);\n            return _context.abrupt(\"return\", (0, deserialize_1.deserializeMint)(data));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function getMintInfo(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.cache = {\n  emitter: new eventEmitter_1.EventEmitter(),\n  query: function () {\n    var _query = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection, pubKey, parser) {\n      var id, address, account, query;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (typeof pubKey === 'string') {\n                id = new web3_js_1.PublicKey(pubKey);\n              } else {\n                id = pubKey;\n              }\n\n              address = id.toBase58();\n              account = exports.genericCache.get(address);\n\n              if (!account) {\n                _context2.next = 5;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", account);\n\n            case 5:\n              query = pendingCalls.get(address);\n\n              if (!query) {\n                _context2.next = 8;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", query);\n\n            case 8:\n              // TODO: refactor to use multiple accounts query with flush like behavior\n              query = connection.getAccountInfo(id).then(function (data) {\n                if (!data) {\n                  throw new Error('Account not found');\n                }\n\n                return exports.cache.add(id, data, parser);\n              });\n              pendingCalls.set(address, query);\n              return _context2.abrupt(\"return\", query);\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function query(_x3, _x4, _x5) {\n      return _query.apply(this, arguments);\n    }\n\n    return query;\n  }(),\n  add: function add(id, obj, parser, isActive) {\n    var address = typeof id === 'string' ? id : id === null || id === void 0 ? void 0 : id.toBase58();\n    var deserialize = parser ? parser : keyToAccountParser.get(address);\n\n    if (!deserialize) {\n      throw new Error('Deserializer needs to be registered or passed as a parameter');\n    }\n\n    exports.cache.registerParser(id, deserialize);\n    pendingCalls.delete(address);\n    var account = deserialize(address, obj);\n\n    if (!account) {\n      return;\n    }\n\n    if (isActive === undefined) isActive = true;else if (isActive instanceof Function) isActive = isActive(account);\n    var isNew = !exports.genericCache.has(address);\n    exports.genericCache.set(address, account);\n    exports.cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\n    return account;\n  },\n  get: function get(pubKey) {\n    var key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return exports.genericCache.get(key);\n  },\n  delete: function _delete(pubKey) {\n    var key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    if (exports.genericCache.get(key)) {\n      exports.genericCache.delete(key);\n      exports.cache.emitter.raiseCacheDeleted(key);\n      return true;\n    }\n\n    return false;\n  },\n  byParser: function byParser(parser) {\n    var result = [];\n\n    var _iterator = _createForOfIteratorHelper(keyToAccountParser.keys()),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var id = _step.value;\n\n        if (keyToAccountParser.get(id) === parser) {\n          result.push(id);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return result;\n  },\n  registerParser: function registerParser(pubkey, parser) {\n    if (pubkey) {\n      var address = typeof pubkey === 'string' ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();\n      keyToAccountParser.set(address, parser);\n    }\n\n    return pubkey;\n  },\n  queryMint: function () {\n    var _queryMint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(connection, pubKey) {\n      var id, address, mint, query;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (typeof pubKey === 'string') {\n                id = new web3_js_1.PublicKey(pubKey);\n              } else {\n                id = pubKey;\n              }\n\n              address = id.toBase58();\n              mint = mintCache.get(address);\n\n              if (!mint) {\n                _context3.next = 5;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", mint);\n\n            case 5:\n              query = pendingMintCalls.get(address);\n\n              if (!query) {\n                _context3.next = 8;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", query);\n\n            case 8:\n              query = getMintInfo(connection, id).then(function (data) {\n                pendingMintCalls.delete(address);\n                mintCache.set(address, data);\n                return data;\n              });\n              pendingMintCalls.set(address, query);\n              return _context3.abrupt(\"return\", query);\n\n            case 11:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    function queryMint(_x6, _x7) {\n      return _queryMint.apply(this, arguments);\n    }\n\n    return queryMint;\n  }(),\n  getMint: function getMint(pubKey) {\n    var key;\n\n    if (typeof pubKey !== 'string') {\n      key = pubKey.toBase58();\n    } else {\n      key = pubKey;\n    }\n\n    return mintCache.get(key);\n  },\n  addMint: function addMint(pubKey, obj) {\n    var mint = (0, deserialize_1.deserializeMint)(obj.data);\n    var id = pubKey.toBase58();\n    mintCache.set(id, mint);\n    return mint;\n  }\n};\n\nvar getCachedAccount = function getCachedAccount(predicate) {\n  var _iterator2 = _createForOfIteratorHelper(exports.genericCache.values()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var account = _step2.value;\n\n      if (predicate(account)) {\n        return account;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\nexports.getCachedAccount = getCachedAccount;","map":{"version":3,"sources":["../../../../src/contexts/accounts/cache.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getCachedAccount = exports.cache = exports.genericCache = void 0;\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst eventEmitter_1 = require(\"../../utils/eventEmitter\");\r\nconst deserialize_1 = require(\"./deserialize\");\r\nexports.genericCache = new Map();\r\nconst mintCache = new Map();\r\nconst pendingCalls = new Map();\r\nconst pendingMintCalls = new Map();\r\nconst keyToAccountParser = new Map();\r\nconst getMintInfo = async (connection, pubKey) => {\r\n    const info = await connection.getAccountInfo(pubKey);\r\n    if (info === null) {\r\n        throw new Error('Failed to find mint account');\r\n    }\r\n    const data = Buffer.from(info.data);\r\n    return (0, deserialize_1.deserializeMint)(data);\r\n};\r\nexports.cache = {\r\n    emitter: new eventEmitter_1.EventEmitter(),\r\n    query: async (connection, pubKey, parser) => {\r\n        let id;\r\n        if (typeof pubKey === 'string') {\r\n            id = new web3_js_1.PublicKey(pubKey);\r\n        }\r\n        else {\r\n            id = pubKey;\r\n        }\r\n        const address = id.toBase58();\r\n        const account = exports.genericCache.get(address);\r\n        if (account) {\r\n            return account;\r\n        }\r\n        let query = pendingCalls.get(address);\r\n        if (query) {\r\n            return query;\r\n        }\r\n        // TODO: refactor to use multiple accounts query with flush like behavior\r\n        query = connection.getAccountInfo(id).then(data => {\r\n            if (!data) {\r\n                throw new Error('Account not found');\r\n            }\r\n            return exports.cache.add(id, data, parser);\r\n        });\r\n        pendingCalls.set(address, query);\r\n        return query;\r\n    },\r\n    add: (id, obj, parser, isActive) => {\r\n        const address = typeof id === 'string' ? id : id === null || id === void 0 ? void 0 : id.toBase58();\r\n        const deserialize = parser ? parser : keyToAccountParser.get(address);\r\n        if (!deserialize) {\r\n            throw new Error('Deserializer needs to be registered or passed as a parameter');\r\n        }\r\n        exports.cache.registerParser(id, deserialize);\r\n        pendingCalls.delete(address);\r\n        const account = deserialize(address, obj);\r\n        if (!account) {\r\n            return;\r\n        }\r\n        if (isActive === undefined)\r\n            isActive = true;\r\n        else if (isActive instanceof Function)\r\n            isActive = isActive(account);\r\n        const isNew = !exports.genericCache.has(address);\r\n        exports.genericCache.set(address, account);\r\n        exports.cache.emitter.raiseCacheUpdated(address, isNew, deserialize, isActive);\r\n        return account;\r\n    },\r\n    get: (pubKey) => {\r\n        let key;\r\n        if (typeof pubKey !== 'string') {\r\n            key = pubKey.toBase58();\r\n        }\r\n        else {\r\n            key = pubKey;\r\n        }\r\n        return exports.genericCache.get(key);\r\n    },\r\n    delete: (pubKey) => {\r\n        let key;\r\n        if (typeof pubKey !== 'string') {\r\n            key = pubKey.toBase58();\r\n        }\r\n        else {\r\n            key = pubKey;\r\n        }\r\n        if (exports.genericCache.get(key)) {\r\n            exports.genericCache.delete(key);\r\n            exports.cache.emitter.raiseCacheDeleted(key);\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n    byParser: (parser) => {\r\n        const result = [];\r\n        for (const id of keyToAccountParser.keys()) {\r\n            if (keyToAccountParser.get(id) === parser) {\r\n                result.push(id);\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n    registerParser: (pubkey, parser) => {\r\n        if (pubkey) {\r\n            const address = typeof pubkey === 'string' ? pubkey : pubkey === null || pubkey === void 0 ? void 0 : pubkey.toBase58();\r\n            keyToAccountParser.set(address, parser);\r\n        }\r\n        return pubkey;\r\n    },\r\n    queryMint: async (connection, pubKey) => {\r\n        let id;\r\n        if (typeof pubKey === 'string') {\r\n            id = new web3_js_1.PublicKey(pubKey);\r\n        }\r\n        else {\r\n            id = pubKey;\r\n        }\r\n        const address = id.toBase58();\r\n        const mint = mintCache.get(address);\r\n        if (mint) {\r\n            return mint;\r\n        }\r\n        let query = pendingMintCalls.get(address);\r\n        if (query) {\r\n            return query;\r\n        }\r\n        query = getMintInfo(connection, id).then(data => {\r\n            pendingMintCalls.delete(address);\r\n            mintCache.set(address, data);\r\n            return data;\r\n        });\r\n        pendingMintCalls.set(address, query);\r\n        return query;\r\n    },\r\n    getMint: (pubKey) => {\r\n        let key;\r\n        if (typeof pubKey !== 'string') {\r\n            key = pubKey.toBase58();\r\n        }\r\n        else {\r\n            key = pubKey;\r\n        }\r\n        return mintCache.get(key);\r\n    },\r\n    addMint: (pubKey, obj) => {\r\n        const mint = (0, deserialize_1.deserializeMint)(obj.data);\r\n        const id = pubKey.toBase58();\r\n        mintCache.set(id, mint);\r\n        return mint;\r\n    },\r\n};\r\nconst getCachedAccount = (predicate) => {\r\n    for (const account of exports.genericCache.values()) {\r\n        if (predicate(account)) {\r\n            return account;\r\n        }\r\n    }\r\n};\r\nexports.getCachedAccount = getCachedAccount;\r\n//# sourceMappingURL=cache.js.map"]},"metadata":{},"sourceType":"script"}