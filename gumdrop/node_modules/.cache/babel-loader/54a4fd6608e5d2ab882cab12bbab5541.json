{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Users\\\\AHSAN PC\\\\Desktop\\\\digitsu\\\\gamp\\\\js\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\");\n\nvar _asyncToGenerator = require(\"C:\\\\Users\\\\AHSAN PC\\\\Desktop\\\\digitsu\\\\gamp\\\\js\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"C:\\\\Users\\\\AHSAN PC\\\\Desktop\\\\digitsu\\\\gamp\\\\js\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\slicedToArray.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAccount = exports.useMint = exports.useNativeAccount = exports.AccountsProvider = exports.useAccountsContext = void 0;\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar wallet_adapter_react_1 = require(\"@solana/wallet-adapter-react\");\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar spl_token_1 = require(\"@solana/spl-token\");\n\nvar connection_1 = require(\"../../contexts/connection\");\n\nvar ids_1 = require(\"../../utils/ids\");\n\nvar programIds_1 = require(\"../../utils/programIds\");\n\nvar cache_1 = require(\"./cache\");\n\nvar deserialize_1 = require(\"./deserialize\");\n\nvar parsesrs_1 = require(\"./parsesrs\");\n\nvar AccountsContext = react_1.default.createContext(null);\n\nvar useAccountsContext = function useAccountsContext() {\n  var context = (0, react_1.useContext)(AccountsContext);\n  return context;\n};\n\nexports.useAccountsContext = useAccountsContext;\n\nfunction wrapNativeAccount(pubkey, account) {\n  if (!account) {\n    return undefined;\n  }\n\n  var key = new web3_js_1.PublicKey(pubkey);\n  return {\n    pubkey: pubkey,\n    account: account,\n    info: {\n      address: key,\n      mint: ids_1.WRAPPED_SOL_MINT,\n      owner: key,\n      amount: new spl_token_1.u64(account.lamports),\n      delegate: null,\n      delegatedAmount: new spl_token_1.u64(0),\n      isInitialized: true,\n      isFrozen: false,\n      isNative: true,\n      rentExemptReserve: null,\n      closeAuthority: null\n    }\n  };\n}\n\nvar UseNativeAccount = function UseNativeAccount() {\n  var connection = (0, connection_1.useConnection)();\n\n  var _ref = (0, wallet_adapter_react_1.useWallet)(),\n      publicKey = _ref.publicKey;\n\n  var _ref2 = (0, react_1.useState)(),\n      _ref3 = _slicedToArray(_ref2, 2),\n      nativeAccount = _ref3[0],\n      setNativeAccount = _ref3[1];\n\n  var updateCache = (0, react_1.useCallback)(function (account) {\n    if (publicKey) {\n      var wrapped = wrapNativeAccount(publicKey.toBase58(), account);\n\n      if (wrapped !== undefined) {\n        var id = publicKey.toBase58();\n        cache_1.cache.registerParser(id, parsesrs_1.TokenAccountParser);\n        cache_1.genericCache.set(id, wrapped);\n        cache_1.cache.emitter.raiseCacheUpdated(id, false, parsesrs_1.TokenAccountParser, true);\n      }\n    }\n  }, [publicKey]);\n  (0, react_1.useEffect)(function () {\n    var subId = 0;\n\n    var updateAccount = function updateAccount(account) {\n      if (account) {\n        updateCache(account);\n        setNativeAccount(account);\n      }\n    };\n\n    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var account;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!connection || !publicKey)) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 2:\n              _context.next = 4;\n              return connection.getAccountInfo(publicKey);\n\n            case 4:\n              account = _context.sent;\n              updateAccount(account);\n              subId = connection.onAccountChange(publicKey, updateAccount);\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n\n    return function () {\n      if (subId) {\n        connection.removeAccountChangeListener(subId);\n      }\n    };\n  }, [setNativeAccount, publicKey, connection, updateCache]);\n  return {\n    nativeAccount: nativeAccount\n  };\n};\n\nvar PRECACHED_OWNERS = new Set();\n\nvar precacheUserTokenAccounts = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection, owner) {\n    var accounts;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (owner) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 2:\n            // used for filtering account updates over websocket\n            PRECACHED_OWNERS.add(owner.toBase58()); // user accounts are updated via ws subscription\n\n            _context2.next = 5;\n            return connection.getTokenAccountsByOwner(owner, {\n              programId: (0, programIds_1.programIds)().token\n            });\n\n          case 5:\n            accounts = _context2.sent;\n            accounts.value.forEach(function (info) {\n              cache_1.cache.add(info.pubkey.toBase58(), info.account, parsesrs_1.TokenAccountParser);\n            });\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function precacheUserTokenAccounts(_x, _x2) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nfunction AccountsProvider(_ref6) {\n  var _ref6$children = _ref6.children,\n      children = _ref6$children === void 0 ? null : _ref6$children;\n  var connection = (0, connection_1.useConnection)();\n\n  var _ref7 = (0, wallet_adapter_react_1.useWallet)(),\n      publicKey = _ref7.publicKey;\n\n  var _ref8 = (0, react_1.useState)([]),\n      _ref9 = _slicedToArray(_ref8, 2),\n      tokenAccounts = _ref9[0],\n      setTokenAccounts = _ref9[1];\n\n  var _ref10 = (0, react_1.useState)([]),\n      _ref11 = _slicedToArray(_ref10, 2),\n      userAccounts = _ref11[0],\n      setUserAccounts = _ref11[1];\n\n  var _UseNativeAccount = UseNativeAccount(),\n      nativeAccount = _UseNativeAccount.nativeAccount;\n\n  var walletKey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();\n  var selectUserAccounts = (0, react_1.useCallback)(function () {\n    return cache_1.cache.byParser(parsesrs_1.TokenAccountParser).map(function (id) {\n      return cache_1.cache.get(id);\n    }).filter(function (a) {\n      return a && a.info.owner.toBase58() === walletKey;\n    }).map(function (a) {\n      return a;\n    });\n  }, [walletKey, nativeAccount]);\n  (0, react_1.useEffect)(function () {\n    var accounts = selectUserAccounts().filter(function (a) {\n      return a !== undefined;\n    });\n    setUserAccounts(accounts);\n  }, [nativeAccount, tokenAccounts, selectUserAccounts]);\n  (0, react_1.useEffect)(function () {\n    var subs = [];\n    cache_1.cache.emitter.onCache(function (args) {\n      if (args.isNew && args.isActive) {\n        var id = args.id;\n        var deserialize = args.parser;\n        connection.onAccountChange(new web3_js_1.PublicKey(id), function (info) {\n          cache_1.cache.add(id, info, deserialize);\n        });\n      }\n    });\n    return function () {\n      subs.forEach(function (id) {\n        return connection.removeAccountChangeListener(id);\n      });\n    };\n  }, [connection]);\n  (0, react_1.useEffect)(function () {\n    if (!connection || !publicKey) {\n      setTokenAccounts([]);\n    } else {\n      precacheUserTokenAccounts(connection, publicKey).then(function () {\n        setTokenAccounts(selectUserAccounts());\n      }); // This can return different types of accounts: token-account, mint, multisig\n      // TODO: web3.js expose ability to filter.\n      // this should use only filter syntax to only get accounts that are owned by user\n\n      var tokenSubID = connection.onProgramAccountChange((0, programIds_1.programIds)().token, function (info) {\n        // TODO: fix type in web3.js\n        var id = info.accountId; // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\n\n        if (info.accountInfo.data.length === spl_token_1.AccountLayout.span) {\n          var data = (0, deserialize_1.deserializeAccount)(info.accountInfo.data);\n\n          if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\n            cache_1.cache.add(id, info.accountInfo, parsesrs_1.TokenAccountParser);\n            setTokenAccounts(selectUserAccounts());\n          }\n        }\n      }, 'singleGossip');\n      return function () {\n        connection.removeProgramAccountChangeListener(tokenSubID);\n      };\n    }\n  }, [connection, publicKey, selectUserAccounts]);\n  return react_1.default.createElement(AccountsContext.Provider, {\n    value: {\n      userAccounts: userAccounts,\n      nativeAccount: nativeAccount\n    }\n  }, children);\n}\n\nexports.AccountsProvider = AccountsProvider;\n\nfunction useNativeAccount() {\n  var context = (0, react_1.useContext)(AccountsContext);\n  return {\n    account: context.nativeAccount\n  };\n}\n\nexports.useNativeAccount = useNativeAccount;\n\nfunction useMint(key) {\n  var connection = (0, connection_1.useConnection)();\n\n  var _ref12 = (0, react_1.useState)(),\n      _ref13 = _slicedToArray(_ref12, 2),\n      mint = _ref13[0],\n      setMint = _ref13[1];\n\n  var id = typeof key === 'string' ? key : key === null || key === void 0 ? void 0 : key.toBase58();\n  (0, react_1.useEffect)(function () {\n    if (!id) {\n      return;\n    }\n\n    cache_1.cache.query(connection, id, parsesrs_1.MintParser).then(function (acc) {\n      return setMint(acc.info);\n    }).catch(function (err) {\n      return console.log(err);\n    });\n    var dispose = cache_1.cache.emitter.onCache(function (e) {\n      var event = e;\n\n      if (event.id === id) {\n        cache_1.cache.query(connection, id, parsesrs_1.MintParser).then(function (mint) {\n          return setMint(mint.info);\n        });\n      }\n    });\n    return function () {\n      dispose();\n    };\n  }, [connection, id]);\n  return mint;\n}\n\nexports.useMint = useMint;\n\nfunction useAccount(pubKey) {\n  var connection = (0, connection_1.useConnection)();\n\n  var _ref14 = (0, react_1.useState)(),\n      _ref15 = _slicedToArray(_ref14, 2),\n      account = _ref15[0],\n      setAccount = _ref15[1];\n\n  var key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\n  (0, react_1.useEffect)(function () {\n    var query = /*#__PURE__*/function () {\n      var _ref16 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var acc;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n\n                if (key) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 3:\n                _context3.next = 5;\n                return cache_1.cache.query(connection, key, parsesrs_1.TokenAccountParser).catch(function (err) {\n                  return console.log(err);\n                });\n\n              case 5:\n                acc = _context3.sent;\n\n                if (acc) {\n                  setAccount(acc);\n                }\n\n                _context3.next = 12;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](0);\n                console.error(_context3.t0);\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[0, 9]]);\n      }));\n\n      return function query() {\n        return _ref16.apply(this, arguments);\n      };\n    }();\n\n    query();\n    var dispose = cache_1.cache.emitter.onCache(function (e) {\n      var event = e;\n\n      if (event.id === key) {\n        query();\n      }\n    });\n    return function () {\n      dispose();\n    };\n  }, [connection, key]);\n  return account;\n}\n\nexports.useAccount = useAccount;","map":{"version":3,"sources":["../../../../src/contexts/accounts/accounts.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.useAccount = exports.useMint = exports.useNativeAccount = exports.AccountsProvider = exports.useAccountsContext = void 0;\r\nconst react_1 = __importStar(require(\"react\"));\r\nconst wallet_adapter_react_1 = require(\"@solana/wallet-adapter-react\");\r\nconst web3_js_1 = require(\"@solana/web3.js\");\r\nconst spl_token_1 = require(\"@solana/spl-token\");\r\nconst connection_1 = require(\"../../contexts/connection\");\r\nconst ids_1 = require(\"../../utils/ids\");\r\nconst programIds_1 = require(\"../../utils/programIds\");\r\nconst cache_1 = require(\"./cache\");\r\nconst deserialize_1 = require(\"./deserialize\");\r\nconst parsesrs_1 = require(\"./parsesrs\");\r\nconst AccountsContext = react_1.default.createContext(null);\r\nconst useAccountsContext = () => {\r\n    const context = (0, react_1.useContext)(AccountsContext);\r\n    return context;\r\n};\r\nexports.useAccountsContext = useAccountsContext;\r\nfunction wrapNativeAccount(pubkey, account) {\r\n    if (!account) {\r\n        return undefined;\r\n    }\r\n    const key = new web3_js_1.PublicKey(pubkey);\r\n    return {\r\n        pubkey: pubkey,\r\n        account,\r\n        info: {\r\n            address: key,\r\n            mint: ids_1.WRAPPED_SOL_MINT,\r\n            owner: key,\r\n            amount: new spl_token_1.u64(account.lamports),\r\n            delegate: null,\r\n            delegatedAmount: new spl_token_1.u64(0),\r\n            isInitialized: true,\r\n            isFrozen: false,\r\n            isNative: true,\r\n            rentExemptReserve: null,\r\n            closeAuthority: null,\r\n        },\r\n    };\r\n}\r\nconst UseNativeAccount = () => {\r\n    const connection = (0, connection_1.useConnection)();\r\n    const { publicKey } = (0, wallet_adapter_react_1.useWallet)();\r\n    const [nativeAccount, setNativeAccount] = (0, react_1.useState)();\r\n    const updateCache = (0, react_1.useCallback)(account => {\r\n        if (publicKey) {\r\n            const wrapped = wrapNativeAccount(publicKey.toBase58(), account);\r\n            if (wrapped !== undefined) {\r\n                const id = publicKey.toBase58();\r\n                cache_1.cache.registerParser(id, parsesrs_1.TokenAccountParser);\r\n                cache_1.genericCache.set(id, wrapped);\r\n                cache_1.cache.emitter.raiseCacheUpdated(id, false, parsesrs_1.TokenAccountParser, true);\r\n            }\r\n        }\r\n    }, [publicKey]);\r\n    (0, react_1.useEffect)(() => {\r\n        let subId = 0;\r\n        const updateAccount = (account) => {\r\n            if (account) {\r\n                updateCache(account);\r\n                setNativeAccount(account);\r\n            }\r\n        };\r\n        (async () => {\r\n            if (!connection || !publicKey) {\r\n                return;\r\n            }\r\n            const account = await connection.getAccountInfo(publicKey);\r\n            updateAccount(account);\r\n            subId = connection.onAccountChange(publicKey, updateAccount);\r\n        })();\r\n        return () => {\r\n            if (subId) {\r\n                connection.removeAccountChangeListener(subId);\r\n            }\r\n        };\r\n    }, [setNativeAccount, publicKey, connection, updateCache]);\r\n    return { nativeAccount };\r\n};\r\nconst PRECACHED_OWNERS = new Set();\r\nconst precacheUserTokenAccounts = async (connection, owner) => {\r\n    if (!owner) {\r\n        return;\r\n    }\r\n    // used for filtering account updates over websocket\r\n    PRECACHED_OWNERS.add(owner.toBase58());\r\n    // user accounts are updated via ws subscription\r\n    const accounts = await connection.getTokenAccountsByOwner(owner, {\r\n        programId: (0, programIds_1.programIds)().token,\r\n    });\r\n    accounts.value.forEach(info => {\r\n        cache_1.cache.add(info.pubkey.toBase58(), info.account, parsesrs_1.TokenAccountParser);\r\n    });\r\n};\r\nfunction AccountsProvider({ children = null, }) {\r\n    const connection = (0, connection_1.useConnection)();\r\n    const { publicKey } = (0, wallet_adapter_react_1.useWallet)();\r\n    const [tokenAccounts, setTokenAccounts] = (0, react_1.useState)([]);\r\n    const [userAccounts, setUserAccounts] = (0, react_1.useState)([]);\r\n    const { nativeAccount } = UseNativeAccount();\r\n    const walletKey = publicKey === null || publicKey === void 0 ? void 0 : publicKey.toBase58();\r\n    const selectUserAccounts = (0, react_1.useCallback)(() => {\r\n        return cache_1.cache\r\n            .byParser(parsesrs_1.TokenAccountParser)\r\n            .map(id => cache_1.cache.get(id))\r\n            .filter(a => a && a.info.owner.toBase58() === walletKey)\r\n            .map(a => a);\r\n    }, [walletKey, nativeAccount]);\r\n    (0, react_1.useEffect)(() => {\r\n        const accounts = selectUserAccounts().filter(a => a !== undefined);\r\n        setUserAccounts(accounts);\r\n    }, [nativeAccount, tokenAccounts, selectUserAccounts]);\r\n    (0, react_1.useEffect)(() => {\r\n        const subs = [];\r\n        cache_1.cache.emitter.onCache(args => {\r\n            if (args.isNew && args.isActive) {\r\n                const id = args.id;\r\n                const deserialize = args.parser;\r\n                connection.onAccountChange(new web3_js_1.PublicKey(id), info => {\r\n                    cache_1.cache.add(id, info, deserialize);\r\n                });\r\n            }\r\n        });\r\n        return () => {\r\n            subs.forEach(id => connection.removeAccountChangeListener(id));\r\n        };\r\n    }, [connection]);\r\n    (0, react_1.useEffect)(() => {\r\n        if (!connection || !publicKey) {\r\n            setTokenAccounts([]);\r\n        }\r\n        else {\r\n            precacheUserTokenAccounts(connection, publicKey).then(() => {\r\n                setTokenAccounts(selectUserAccounts());\r\n            });\r\n            // This can return different types of accounts: token-account, mint, multisig\r\n            // TODO: web3.js expose ability to filter.\r\n            // this should use only filter syntax to only get accounts that are owned by user\r\n            const tokenSubID = connection.onProgramAccountChange((0, programIds_1.programIds)().token, info => {\r\n                // TODO: fix type in web3.js\r\n                const id = info.accountId;\r\n                // TODO: do we need a better way to identify layout (maybe a enum identifing type?)\r\n                if (info.accountInfo.data.length === spl_token_1.AccountLayout.span) {\r\n                    const data = (0, deserialize_1.deserializeAccount)(info.accountInfo.data);\r\n                    if (PRECACHED_OWNERS.has(data.owner.toBase58())) {\r\n                        cache_1.cache.add(id, info.accountInfo, parsesrs_1.TokenAccountParser);\r\n                        setTokenAccounts(selectUserAccounts());\r\n                    }\r\n                }\r\n            }, 'singleGossip');\r\n            return () => {\r\n                connection.removeProgramAccountChangeListener(tokenSubID);\r\n            };\r\n        }\r\n    }, [connection, publicKey, selectUserAccounts]);\r\n    return (react_1.default.createElement(AccountsContext.Provider, { value: {\r\n            userAccounts,\r\n            nativeAccount,\r\n        } }, children));\r\n}\r\nexports.AccountsProvider = AccountsProvider;\r\nfunction useNativeAccount() {\r\n    const context = (0, react_1.useContext)(AccountsContext);\r\n    return {\r\n        account: context.nativeAccount,\r\n    };\r\n}\r\nexports.useNativeAccount = useNativeAccount;\r\nfunction useMint(key) {\r\n    const connection = (0, connection_1.useConnection)();\r\n    const [mint, setMint] = (0, react_1.useState)();\r\n    const id = typeof key === 'string' ? key : key === null || key === void 0 ? void 0 : key.toBase58();\r\n    (0, react_1.useEffect)(() => {\r\n        if (!id) {\r\n            return;\r\n        }\r\n        cache_1.cache\r\n            .query(connection, id, parsesrs_1.MintParser)\r\n            .then(acc => setMint(acc.info))\r\n            .catch(err => console.log(err));\r\n        const dispose = cache_1.cache.emitter.onCache(e => {\r\n            const event = e;\r\n            if (event.id === id) {\r\n                cache_1.cache\r\n                    .query(connection, id, parsesrs_1.MintParser)\r\n                    .then(mint => setMint(mint.info));\r\n            }\r\n        });\r\n        return () => {\r\n            dispose();\r\n        };\r\n    }, [connection, id]);\r\n    return mint;\r\n}\r\nexports.useMint = useMint;\r\nfunction useAccount(pubKey) {\r\n    const connection = (0, connection_1.useConnection)();\r\n    const [account, setAccount] = (0, react_1.useState)();\r\n    const key = pubKey === null || pubKey === void 0 ? void 0 : pubKey.toBase58();\r\n    (0, react_1.useEffect)(() => {\r\n        const query = async () => {\r\n            try {\r\n                if (!key) {\r\n                    return;\r\n                }\r\n                const acc = await cache_1.cache\r\n                    .query(connection, key, parsesrs_1.TokenAccountParser)\r\n                    .catch(err => console.log(err));\r\n                if (acc) {\r\n                    setAccount(acc);\r\n                }\r\n            }\r\n            catch (err) {\r\n                console.error(err);\r\n            }\r\n        };\r\n        query();\r\n        const dispose = cache_1.cache.emitter.onCache(e => {\r\n            const event = e;\r\n            if (event.id === key) {\r\n                query();\r\n            }\r\n        });\r\n        return () => {\r\n            dispose();\r\n        };\r\n    }, [connection, key]);\r\n    return account;\r\n}\r\nexports.useAccount = useAccount;\r\n//# sourceMappingURL=accounts.js.map"]},"metadata":{},"sourceType":"script"}